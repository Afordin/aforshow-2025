---
import "@styles/countdown.css";

interface Props {
  class?: string;
}

interface Unit {
  key: "day" | "hour" | "minute" | "second";
  label: string;
}

const { class: className } = Astro.props;

const units: Unit[] = [
  { key: "day", label: "DÃ­as" },
  { key: "hour", label: "Horas" },
  { key: "minute", label: "Minutos" },
  { key: "second", label: "Segundos" },
];
---

<section
  class={`flex flex-col gap-4 items-center mb-5 ${className || ""}`}
  style="--stagger:4"
>
  <div class="flex gap-4 md:gap-6 items-center justify-center w-full max-w-2xl">
    {
      units.map(({ key, label }) => (
        <div class="flex flex-col items-center">
          <div class="rounded-lg px-3 md:px-4 min-w-[60px] md:min-w-[80px]">
            <span
              class="countdown-number block text-hero-title font-bold text-cs-black text-center tabular-nums"
              data-unit={key}
            >
              00
            </span>
          </div>
          <span class="text-hero-subtitle font-medium text-cs-black/70 font-handlee text-center">
            {label}
          </span>
        </div>
      ))
    }
  </div>
</section>

<script>
  type UnitKey = "day" | "hour" | "minute" | "second";
  type CountdownValues = Record<UnitKey, number>;

  let intervalId: ReturnType<typeof setInterval> | null = null;
  const COUNTDOWN_FROM = new Date("2025-10-03T20:00:00").getTime();
  const TIME_UNITS = {
    SECOND: 1000,
    MINUTE: 60000,
    HOUR: 3600000,
    DAY: 86400000,
  };

  function getUnitValue(unit: string, values: CountdownValues): string {
    return String(values[unit as UnitKey]).padStart(2, "0");
  }

  function processNumbers(
    $numbers: NodeListOf<HTMLElement>,
    values: CountdownValues,
    opts?: {
      setTransition?: boolean;
      updateText?: boolean;
      clearTransition?: boolean;
    }
  ): void {
    $numbers.forEach((el) => {
      const unit = el.dataset.unit ?? "";
      const newValue = getUnitValue(unit, values);

      if (opts?.setTransition) {
        el.style.viewTransitionName = el.textContent === newValue ? "none" : "";
      }
      if (opts?.updateText && el.textContent !== newValue) {
        el.textContent = newValue;
      }
      if (opts?.clearTransition) {
        el.style.viewTransitionName = "";
      }
    });
  }

  function updateCountdown(): void {
    const distance = Math.max(0, COUNTDOWN_FROM - Date.now());
    const values: CountdownValues = {
      day: Math.floor(distance / TIME_UNITS.DAY),
      hour: Math.floor((distance % TIME_UNITS.DAY) / TIME_UNITS.HOUR),
      minute: Math.floor((distance % TIME_UNITS.HOUR) / TIME_UNITS.MINUTE),
      second: Math.floor((distance % TIME_UNITS.MINUTE) / TIME_UNITS.SECOND),
    };

    const $numbers =
      document.querySelectorAll<HTMLElement>(".countdown-number");

    if (document.startViewTransition) {
      processNumbers($numbers, values, { setTransition: true });

      document
        .startViewTransition(() => {
          processNumbers($numbers, values, { updateText: true });
        })
        .finished.then(() => {
          processNumbers($numbers, values, { clearTransition: true });
        });
    } else {
      processNumbers($numbers, values, {
        updateText: true,
        clearTransition: true,
      });
    }
  }

  function startCountdown() {
    if (intervalId === null) {
      updateCountdown();
      intervalId = setInterval(updateCountdown, 1000);
    }
  }

  function stopCountdown() {
    if (intervalId !== null) {
      clearInterval(intervalId);
      intervalId = null;
    }
  }

  startCountdown();

  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (
        mutation.type === "attributes" &&
        mutation.attributeName === "style"
      ) {
        const hasStyle = document.body.hasAttribute("style");
        if (hasStyle) {
          stopCountdown();
        } else {
          startCountdown();
        }
      }
    });
  });

  observer.observe(document.body, { attributes: true, attributeFilter: ["style"] });
</script>
